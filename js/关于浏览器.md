### 关于浏览器

#### 1. 关于缓存

- **强缓存**：

    **Expires**：即过期时间，存在于服务端返回的响应头中，告诉浏览器在这个过期时间之前可以直接从缓存里面获取数据，无需再次请求。eg：Expires: Wed, 22 Nov 2019  08:41:00 GMT 。但是**服务器的时间和浏览器的时间可能并不一致** 所以HTTP1.1版本中弃用了

 **Cache-Contro**：有各种属性

    1. public：客户端和代理服务器都可以缓存。甚至包括中间的代理节点

    2. private：只能浏览器能缓存，节点不行。

    3.  no-cache ：跳过当前的强缓存，发送http，即直接进入 协商缓存阶段。

    4. no-store：不进行任何形式的缓存。

    5. max-age：返回后多少s内，可以直接使用缓存。

    6. s-maxage：这和`max-age`长得比较像，但是区别在于s-maxage是针对代理服务器的缓存时间

    如果强缓存失效。就会进入 **协商缓存**

    

- **协商缓存**：

    强缓存失效后，浏览器在请求头中携带相应的`缓存tag`来向服务器发请求，由服务器根据这个tag，来决定是否使用缓存，这就是**协商缓存**。

    **Last-Modified**：服务器最后的修改时间，服务器拿到请求头中的`If-Modified-Since`的字段后，其实会和这个服务器中`该资源的最后修改时间`对比:

    如果请求头中的这个值小于最后修改时间，说明是时候更新了。返回新的资源，跟常规的HTTP请求响应的流程一样。

    否则返回304，告诉浏览器直接用缓存。

  **ETag**：服务器根据文件的内容生成的唯一标识，内容改变，这个值就会变，服务器会通过响应头把这个值给浏览器。浏览器接收到`ETag`的值，会在下次请求时，将这个值作为**If-None-Match**这个字段的内容，并放到请求头中，然后发给服务器。

服务器接收到**If-None-Match**后，会跟服务器上该资源的**ETag**进行比对:

    如果两者不一样，说明要更新了。返回新的资源，跟常规的HTTP请求响应的流程一样。

    否则返回304，告诉浏览器直接用缓存。



#### 2. 缓存位置

- **Service Worker**:

- **Memory Cache**  内存缓存

- **Disk Cache** 磁盘缓存

- **Push Cache** 推送缓存



### 关于本地缓存

#### 1. cookie

    用来做状态储存的，但是

    容量小，上限只有4KB。

    性能也有缺陷，不管需不需要，请求都会带上完整的cookie。

    Cookie是以纯文本的形似存在的，很容易被截获 篡改。另外，在`HttpOnly`为 false 的情况下，Cookie 信息能直接通过 JS 脚本来读取。



#### 2. localStorge

    和cookie一样的是，同一个域名下，会储存一样的东西。但是

    容量大，上限有5M。

    只存在于客户端，默认是不参与与服务端的通信的，所以没有性能和安全的问题。

    接口封装，可以通过setItem 和getItem 来进行操作



#### 3. sessionStorage

    和localStorge的 区别就是，不是持久化的存储，页面关闭，就不存在了。



#### indexedDB

    运行在浏览器中的 `非关系型数据库` 理论上是没有上线的。



### 从输入URL到页面呈现到底发了什么？？？

#### 网络篇

##### 1. 构建请求

浏览器会构建请求行：

  // 请求方法是GET，路径为根路径，HTTP协议版本为1.1     

    GET / HTTP/1.1

##### 2. 查找强缓存

#### 3. DNS解析

    通过DNS(域名系统)（是一个将域名和Ip一一映射的系统）等到具体的IP

    浏览器具有DNS数据缓存功能，如果一个域名已经解析过了，会把结果缓存下来，下次的时候就不需要走DNS解析了

#### 4. 建立TCP连接

    TCP：（Transmission Control Protocol，传输控制协议）是一种面向连接的、可靠的、基于字节流的传输层通信协议。

需要注意的是 ，chrome在一个域名下，同时只能有6个TCP连接，超过的需要等待 

建立TCP连接需要经历三个阶段：

    1. 通过  **三次握手**（发送三个数据包确认已经建立连接）建立客户端和服务器之前的连接。

    2. 进行数据传输： 有个重要的机制：接收方收到 数据包以后，必须向发送方 **确认**，如果发送方没有接收到这个 **确认**就会认为这个包丢失了，并重新发送。  发送过程还会有个优化策略。会把**大的数据包拆分成一个个小包** 接收的会按照小包的顺序组装成完整的数据包。

3. 断开连接：数据传输完成后，会通过**四次挥手**    断开连接。



##### 5. 发送HTTP请求

    TCP连接完成后，浏览器可以和服务器开始通信，即可以发送HTTP请求了。需要携带三样东西：**请求头 请求行 请求体** 



#### 解析算法篇

完成了网络请求和响应后，如果响应头中`Content-Type`的值是`text/html`，浏览器的`解析`和`渲染`就会工作了。

首先 **解析**分为：

    **1. 构建DOM树**

    **2. 样式计算**

    **3. 生成布居树（Layout Tree）**



#### 渲染过程篇

1. 建立`图层树`(`Layer Tree`)

2. 生成`绘制列表`

3. 生成`图块`并`栅格化`

4. 显示器显示内容


